package com.enterprise.email.security;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.scheduling.annotation.Scheduled;

import java.io.*;
import java.net.*;
import java.nio.file.*;
import java.security.MessageDigest;
import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.*;
import java.util.regex.Pattern;

/**
 * 漏洞扫描和安全评估服务
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class VulnerabilityScanner {

    private final SecurityEventService securityEventService;
    private final NotificationService notificationService;

    @Value("${security.scan.enabled:true}")
    private boolean scanEnabled;

    @Value("${security.scan.deep-scan:false}")
    private boolean deepScanEnabled;

    @Value("${security.scan.schedule:0 2 * * *}")
    private String scanSchedule;

    // 漏洞数据库
    private final Map<String, VulnerabilityRule> vulnerabilityDB = new ConcurrentHashMap<>();
    
    // 扫描结果
    private final List<VulnerabilityResult> scanResults = Collections.synchronizedList(new ArrayList<>());
    
    // 执行器
    private final ExecutorService scanExecutor = Executors.newFixedThreadPool(5);

    /**
     * 初始化漏洞规则库
     */
    public void initializeVulnerabilityRules() {
        log.info("初始化漏洞规则库...");
        
        // CVE-2021-44228 Log4j漏洞
        vulnerabilityDB.put("CVE-2021-44228", new VulnerabilityRule(
            "CVE-2021-44228",
            "Apache Log4j RCE",
            "Log4j远程代码执行漏洞",
            VulnerabilitySeverity.CRITICAL,
            Arrays.asList("log4j", "${jndi:", "ldap://", "rmi://"),
            this::checkLog4jVulnerability
        ));

        // SQL注入漏洞检测
        vulnerabilityDB.put("SQL_INJECTION", new VulnerabilityRule(
            "SQL_INJECTION",
            "SQL Injection",
            "SQL注入漏洞",
            VulnerabilitySeverity.HIGH,
            Arrays.asList("union select", "' or 1=1", "'; drop table"),
            this::checkSqlInjectionVulnerability
        ));

        // XSS漏洞检测
        vulnerabilityDB.put("XSS_VULNERABILITY", new VulnerabilityRule(
            "XSS_VULNERABILITY",
            "Cross-Site Scripting",
            "跨站脚本攻击漏洞",
            VulnerabilitySeverity.MEDIUM,
            Arrays.asList("<script>", "javascript:", "onerror="),
            this::checkXssVulnerability
        ));

        // 文件上传漏洞
        vulnerabilityDB.put("FILE_UPLOAD", new VulnerabilityRule(
            "FILE_UPLOAD",
            "Arbitrary File Upload",
            "任意文件上传漏洞",
            VulnerabilitySeverity.HIGH,
            Arrays.asList(".jsp", ".php", ".asp", ".exe"),
            this::checkFileUploadVulnerability
        ));

        // 目录遍历漏洞
        vulnerabilityDB.put("PATH_TRAVERSAL", new VulnerabilityRule(
            "PATH_TRAVERSAL",
            "Directory Traversal",
            "目录遍历漏洞",
            VulnerabilitySeverity.MEDIUM,
            Arrays.asList("../", "..\\", "%2e%2e%2f"),
            this::checkPathTraversalVulnerability
        ));

        // 弱密码检测
        vulnerabilityDB.put("WEAK_PASSWORD", new VulnerabilityRule(
            "WEAK_PASSWORD",
            "Weak Password",
            "弱密码漏洞",
            VulnerabilitySeverity.MEDIUM,
            Arrays.asList("123456", "password", "admin"),
            this::checkWeakPasswordVulnerability
        ));

        // 端口暴露检测
        vulnerabilityDB.put("EXPOSED_PORTS", new VulnerabilityRule(
            "EXPOSED_PORTS",
            "Exposed Services",
            "服务端口暴露",
            VulnerabilitySeverity.LOW,
            Arrays.asList("22", "3306", "5432", "6379"),
            this::checkExposedPortsVulnerability
        ));

        log.info("漏洞规则库初始化完成，共加载 {} 个规则", vulnerabilityDB.size());
    }

    /**
     * 执行完整安全扫描
     */
    public CompletableFuture<ScanReport> performFullSecurityScan() {
        return CompletableFuture.supplyAsync(() -> {
            log.info("开始执行完整安全扫描...");
            
            ScanReport report = new ScanReport();
            report.setScanId("SCAN_" + System.currentTimeMillis());
            report.setStartTime(LocalDateTime.now());
            
            try {
                // 1. 网络端口扫描
                List<VulnerabilityResult> portScanResults = performPortScan();
                report.addResults(portScanResults);
                
                // 2. Web应用扫描
                List<VulnerabilityResult> webScanResults = performWebApplicationScan();
                report.addResults(webScanResults);
                
                // 3. 系统配置扫描
                List<VulnerabilityResult> configScanResults = performSystemConfigScan();
                report.addResults(configScanResults);
                
                // 4. 文件系统扫描
                List<VulnerabilityResult> fileScanResults = performFileSystemScan();
                report.addResults(fileScanResults);
                
                // 5. 依赖漏洞扫描
                if (deepScanEnabled) {
                    List<VulnerabilityResult> dependencyScanResults = performDependencyScan();
                    report.addResults(dependencyScanResults);
                }
                
                // 6. 生成风险评估
                RiskAssessment risk = calculateRiskAssessment(report.getResults());
                report.setRiskAssessment(risk);
                
                report.setEndTime(LocalDateTime.now());
                report.setStatus(ScanStatus.COMPLETED);
                
                // 7. 发送扫描报告
                sendScanReport(report);
                
                log.info("安全扫描完成，发现 {} 个漏洞", report.getResults().size());
                
            } catch (Exception e) {
                log.error("安全扫描异常", e);
                report.setStatus(ScanStatus.FAILED);
                report.setError(e.getMessage());
            }
            
            return report;
        }, scanExecutor);
    }

    /**
     * 端口扫描
     */
    private List<VulnerabilityResult> performPortScan() {
        log.info("执行端口扫描...");
        List<VulnerabilityResult> results = new ArrayList<>();
        
        // 常见危险端口
        int[] dangerousPorts = {21, 22, 23, 25, 53, 80, 110, 135, 139, 143, 443, 445, 993, 995, 1433, 3306, 3389, 5432, 6379, 8080, 27017};
        
        String localhost = "127.0.0.1";
        
        for (int port : dangerousPorts) {
            try (Socket socket = new Socket()) {
                socket.connect(new InetSocketAddress(localhost, port), 1000);
                
                VulnerabilityResult result = new VulnerabilityResult();
                result.setVulnerabilityId("EXPOSED_PORT_" + port);
                result.setTitle("暴露的服务端口: " + port);
                result.setDescription("检测到开放的服务端口: " + port);
                result.setSeverity(getPortSeverity(port));
                result.setLocation("localhost:" + port);
                result.setEvidence("端口 " + port + " 处于开放状态");
                result.setRecommendation("检查端口 " + port + " 的服务是否必要，如非必要请关闭");
                
                results.add(result);
                
            } catch (IOException e) {
                // 端口关闭，正常情况
            }
        }
        
        log.info("端口扫描完成，发现 {} 个开放端口", results.size());
        return results;
    }

    /**
     * Web应用扫描
     */
    private List<VulnerabilityResult> performWebApplicationScan() {
        log.info("执行Web应用扫描...");
        List<VulnerabilityResult> results = new ArrayList<>();
        
        try {
            // 扫描常见Web漏洞
            results.addAll(scanForSqlInjection());
            results.addAll(scanForXss());
            results.addAll(scanForDirectoryTraversal());
            results.addAll(scanForFileUpload());
            results.addAll(scanForSecurityHeaders());
            
        } catch (Exception e) {
            log.error("Web应用扫描异常", e);
        }
        
        log.info("Web应用扫描完成，发现 {} 个漏洞", results.size());
        return results;
    }

    /**
     * 系统配置扫描
     */
    private List<VulnerabilityResult> performSystemConfigScan() {
        log.info("执行系统配置扫描...");
        List<VulnerabilityResult> results = new ArrayList<>();
        
        try {
            // SSH配置检查
            results.addAll(checkSshConfiguration());
            
            // 防火墙配置检查
            results.addAll(checkFirewallConfiguration());
            
            // 用户权限检查
            results.addAll(checkUserPermissions());
            
            // 系统更新检查
            results.addAll(checkSystemUpdates());
            
        } catch (Exception e) {
            log.error("系统配置扫描异常", e);
        }
        
        log.info("系统配置扫描完成，发现 {} 个配置问题", results.size());
        return results;
    }

    /**
     * 文件系统扫描
     */
    private List<VulnerabilityResult> performFileSystemScan() {
        log.info("执行文件系统扫描...");
        List<VulnerabilityResult> results = new ArrayList<>();
        
        try {
            // 敏感文件检查
            results.addAll(scanForSensitiveFiles());
            
            // 文件权限检查
            results.addAll(checkFilePermissions());
            
            // 恶意文件检查
            results.addAll(scanForMaliciousFiles());
            
            // 配置文件安全检查
            results.addAll(checkConfigurationFiles());
            
        } catch (Exception e) {
            log.error("文件系统扫描异常", e);
        }
        
        log.info("文件系统扫描完成，发现 {} 个文件安全问题", results.size());
        return results;
    }

    /**
     * 依赖漏洞扫描
     */
    private List<VulnerabilityResult> performDependencyScan() {
        log.info("执行依赖漏洞扫描...");
        List<VulnerabilityResult> results = new ArrayList<>();
        
        try {
            // Maven依赖扫描
            results.addAll(scanMavenDependencies());
            
            // NPM依赖扫描
            results.addAll(scanNpmDependencies());
            
            // 系统包扫描
            results.addAll(scanSystemPackages());
            
        } catch (Exception e) {
            log.error("依赖漏洞扫描异常", e);
        }
        
        log.info("依赖漏洞扫描完成，发现 {} 个依赖漏洞", results.size());
        return results;
    }

    /**
     * Log4j漏洞检测
     */
    private boolean checkLog4jVulnerability(String input) {
        Pattern log4jPattern = Pattern.compile(".*\\$\\{jndi:(ldap|rmi|dns)://.*\\}.*", Pattern.CASE_INSENSITIVE);
        return log4jPattern.matcher(input).matches();
    }

    /**
     * SQL注入漏洞检测
     */
    private boolean checkSqlInjectionVulnerability(String input) {
        String[] sqlPatterns = {
            "union.*select", "insert.*into", "delete.*from", "drop.*table",
            "'.*or.*'.*=.*'", "\".*or.*\".*=.*\"", "or.*1.*=.*1"
        };
        
        for (String pattern : sqlPatterns) {
            if (input.toLowerCase().matches(".*" + pattern + ".*")) {
                return true;
            }
        }
        return false;
    }

    /**
     * XSS漏洞检测
     */
    private boolean checkXssVulnerability(String input) {
        String[] xssPatterns = {
            "<script.*>", "javascript:", "onerror.*=", "onload.*=",
            "eval\\(", "alert\\(", "document\\.cookie"
        };
        
        for (String pattern : xssPatterns) {
            if (input.toLowerCase().matches(".*" + pattern + ".*")) {
                return true;
            }
        }
        return false;
    }

    /**
     * 计算风险评估
     */
    private RiskAssessment calculateRiskAssessment(List<VulnerabilityResult> results) {
        RiskAssessment assessment = new RiskAssessment();
        
        int criticalCount = 0, highCount = 0, mediumCount = 0, lowCount = 0;
        
        for (VulnerabilityResult result : results) {
            switch (result.getSeverity()) {
                case CRITICAL: criticalCount++; break;
                case HIGH: highCount++; break;
                case MEDIUM: mediumCount++; break;
                case LOW: lowCount++; break;
            }
        }
        
        assessment.setCriticalCount(criticalCount);
        assessment.setHighCount(highCount);
        assessment.setMediumCount(mediumCount);
        assessment.setLowCount(lowCount);
        assessment.setTotalCount(results.size());
        
        // 计算风险评分 (0-100)
        int riskScore = criticalCount * 25 + highCount * 15 + mediumCount * 8 + lowCount * 2;
        assessment.setRiskScore(Math.min(riskScore, 100));
        
        // 确定风险等级
        if (riskScore >= 80) {
            assessment.setRiskLevel(RiskLevel.CRITICAL);
        } else if (riskScore >= 60) {
            assessment.setRiskLevel(RiskLevel.HIGH);
        } else if (riskScore >= 40) {
            assessment.setRiskLevel(RiskLevel.MEDIUM);
        } else {
            assessment.setRiskLevel(RiskLevel.LOW);
        }
        
        return assessment;
    }

    /**
     * 发送扫描报告
     */
    private void sendScanReport(ScanReport report) {
        try {
            String reportContent = generateReportContent(report);
            
            if (report.getRiskAssessment().getRiskLevel().ordinal() >= RiskLevel.HIGH.ordinal()) {
                notificationService.sendEmailAlert(
                    "security@company.com",
                    "高风险安全扫描报告",
                    reportContent
                );
            }
            
            // 记录扫描事件
            securityEventService.recordSecurityEvent(
                "VULNERABILITY_SCAN_COMPLETED",
                "SYSTEM",
                String.format("扫描完成，发现 %d 个漏洞，风险等级: %s", 
                             report.getResults().size(),
                             report.getRiskAssessment().getRiskLevel()),
                AttackDetectionInterceptor.SecurityLevel.LOW
            );
            
        } catch (Exception e) {
            log.error("发送扫描报告失败", e);
        }
    }

    /**
     * 生成报告内容
     */
    private String generateReportContent(ScanReport report) {
        StringBuilder content = new StringBuilder();
        
        content.append("安全漏洞扫描报告\n");
        content.append("==================\n\n");
        content.append("扫描ID: ").append(report.getScanId()).append("\n");
        content.append("扫描时间: ").append(report.getStartTime()).append("\n");
        content.append("扫描耗时: ").append(report.getDuration()).append(" 秒\n");
        content.append("扫描状态: ").append(report.getStatus()).append("\n\n");
        
        RiskAssessment risk = report.getRiskAssessment();
        content.append("风险评估\n");
        content.append("--------\n");
        content.append("风险等级: ").append(risk.getRiskLevel()).append("\n");
        content.append("风险评分: ").append(risk.getRiskScore()).append("/100\n");
        content.append("漏洞统计:\n");
        content.append("  严重: ").append(risk.getCriticalCount()).append("\n");
        content.append("  高危: ").append(risk.getHighCount()).append("\n");
        content.append("  中危: ").append(risk.getMediumCount()).append("\n");
        content.append("  低危: ").append(risk.getLowCount()).append("\n\n");
        
        if (!report.getResults().isEmpty()) {
            content.append("漏洞详情\n");
            content.append("--------\n");
            
            int index = 1;
            for (VulnerabilityResult result : report.getResults()) {
                content.append(index++).append(". ").append(result.getTitle()).append("\n");
                content.append("   严重级别: ").append(result.getSeverity()).append("\n");
                content.append("   位置: ").append(result.getLocation()).append("\n");
                content.append("   描述: ").append(result.getDescription()).append("\n");
                content.append("   建议: ").append(result.getRecommendation()).append("\n\n");
            }
        }
        
        return content.toString();
    }

    // 定期扫描任务
    @Scheduled(cron = "${security.scan.schedule:0 2 * * *}")
    public void scheduledSecurityScan() {
        if (scanEnabled) {
            log.info("开始定期安全扫描...");
            performFullSecurityScan();
        }
    }

    // 辅助方法实现
    private VulnerabilitySeverity getPortSeverity(int port) {
        switch (port) {
            case 22: case 3389: return VulnerabilitySeverity.HIGH; // 远程访问
            case 3306: case 5432: case 6379: case 27017: return VulnerabilitySeverity.MEDIUM; // 数据库
            case 80: case 443: case 8080: return VulnerabilitySeverity.LOW; // Web服务
            default: return VulnerabilitySeverity.LOW;
        }
    }

    // 扫描方法的简化实现
    private List<VulnerabilityResult> scanForSqlInjection() { return new ArrayList<>(); }
    private List<VulnerabilityResult> scanForXss() { return new ArrayList<>(); }
    private List<VulnerabilityResult> scanForDirectoryTraversal() { return new ArrayList<>(); }
    private List<VulnerabilityResult> scanForFileUpload() { return new ArrayList<>(); }
    private List<VulnerabilityResult> scanForSecurityHeaders() { return new ArrayList<>(); }
    private List<VulnerabilityResult> checkSshConfiguration() { return new ArrayList<>(); }
    private List<VulnerabilityResult> checkFirewallConfiguration() { return new ArrayList<>(); }
    private List<VulnerabilityResult> checkUserPermissions() { return new ArrayList<>(); }
    private List<VulnerabilityResult> checkSystemUpdates() { return new ArrayList<>(); }
    private List<VulnerabilityResult> scanForSensitiveFiles() { return new ArrayList<>(); }
    private List<VulnerabilityResult> checkFilePermissions() { return new ArrayList<>(); }
    private List<VulnerabilityResult> scanForMaliciousFiles() { return new ArrayList<>(); }
    private List<VulnerabilityResult> checkConfigurationFiles() { return new ArrayList<>(); }
    private List<VulnerabilityResult> scanMavenDependencies() { return new ArrayList<>(); }
    private List<VulnerabilityResult> scanNpmDependencies() { return new ArrayList<>(); }
    private List<VulnerabilityResult> scanSystemPackages() { return new ArrayList<>(); }
    private boolean checkFileUploadVulnerability(String input) { return false; }
    private boolean checkPathTraversalVulnerability(String input) { return false; }
    private boolean checkWeakPasswordVulnerability(String input) { return false; }
    private boolean checkExposedPortsVulnerability(String input) { return false; }

    // 内部类定义
    public enum VulnerabilitySeverity { LOW, MEDIUM, HIGH, CRITICAL }
    public enum ScanStatus { STARTED, RUNNING, COMPLETED, FAILED }
    public enum RiskLevel { LOW, MEDIUM, HIGH, CRITICAL }

    public static class VulnerabilityRule {
        private final String id;
        private final String name;
        private final String description;
        private final VulnerabilitySeverity severity;
        private final List<String> patterns;
        private final java.util.function.Function<String, Boolean> checker;

        public VulnerabilityRule(String id, String name, String description, 
                               VulnerabilitySeverity severity, List<String> patterns,
                               java.util.function.Function<String, Boolean> checker) {
            this.id = id;
            this.name = name;
            this.description = description;
            this.severity = severity;
            this.patterns = patterns;
            this.checker = checker;
        }

        public String getId() { return id; }
        public String getName() { return name; }
        public String getDescription() { return description; }
        public VulnerabilitySeverity getSeverity() { return severity; }
        public List<String> getPatterns() { return patterns; }
        public java.util.function.Function<String, Boolean> getChecker() { return checker; }
    }

    public static class VulnerabilityResult {
        private String vulnerabilityId;
        private String title;
        private String description;
        private VulnerabilitySeverity severity;
        private String location;
        private String evidence;
        private String recommendation;
        private LocalDateTime discoveredTime = LocalDateTime.now();

        // Getters and Setters
        public String getVulnerabilityId() { return vulnerabilityId; }
        public void setVulnerabilityId(String vulnerabilityId) { this.vulnerabilityId = vulnerabilityId; }
        public String getTitle() { return title; }
        public void setTitle(String title) { this.title = title; }
        public String getDescription() { return description; }
        public void setDescription(String description) { this.description = description; }
        public VulnerabilitySeverity getSeverity() { return severity; }
        public void setSeverity(VulnerabilitySeverity severity) { this.severity = severity; }
        public String getLocation() { return location; }
        public void setLocation(String location) { this.location = location; }
        public String getEvidence() { return evidence; }
        public void setEvidence(String evidence) { this.evidence = evidence; }
        public String getRecommendation() { return recommendation; }
        public void setRecommendation(String recommendation) { this.recommendation = recommendation; }
        public LocalDateTime getDiscoveredTime() { return discoveredTime; }
        public void setDiscoveredTime(LocalDateTime discoveredTime) { this.discoveredTime = discoveredTime; }
    }

    public static class ScanReport {
        private String scanId;
        private LocalDateTime startTime;
        private LocalDateTime endTime;
        private ScanStatus status = ScanStatus.STARTED;
        private List<VulnerabilityResult> results = new ArrayList<>();
        private RiskAssessment riskAssessment;
        private String error;

        public void addResults(List<VulnerabilityResult> newResults) {
            this.results.addAll(newResults);
        }

        public long getDuration() {
            if (startTime != null && endTime != null) {
                return java.time.Duration.between(startTime, endTime).getSeconds();
            }
            return 0;
        }

        // Getters and Setters
        public String getScanId() { return scanId; }
        public void setScanId(String scanId) { this.scanId = scanId; }
        public LocalDateTime getStartTime() { return startTime; }
        public void setStartTime(LocalDateTime startTime) { this.startTime = startTime; }
        public LocalDateTime getEndTime() { return endTime; }
        public void setEndTime(LocalDateTime endTime) { this.endTime = endTime; }
        public ScanStatus getStatus() { return status; }
        public void setStatus(ScanStatus status) { this.status = status; }
        public List<VulnerabilityResult> getResults() { return results; }
        public void setResults(List<VulnerabilityResult> results) { this.results = results; }
        public RiskAssessment getRiskAssessment() { return riskAssessment; }
        public void setRiskAssessment(RiskAssessment riskAssessment) { this.riskAssessment = riskAssessment; }
        public String getError() { return error; }
        public void setError(String error) { this.error = error; }
    }

    public static class RiskAssessment {
        private RiskLevel riskLevel;
        private int riskScore;
        private int criticalCount;
        private int highCount;
        private int mediumCount;
        private int lowCount;
        private int totalCount;

        // Getters and Setters
        public RiskLevel getRiskLevel() { return riskLevel; }
        public void setRiskLevel(RiskLevel riskLevel) { this.riskLevel = riskLevel; }
        public int getRiskScore() { return riskScore; }
        public void setRiskScore(int riskScore) { this.riskScore = riskScore; }
        public int getCriticalCount() { return criticalCount; }
        public void setCriticalCount(int criticalCount) { this.criticalCount = criticalCount; }
        public int getHighCount() { return highCount; }
        public void setHighCount(int highCount) { this.highCount = highCount; }
        public int getMediumCount() { return mediumCount; }
        public void setMediumCount(int mediumCount) { this.mediumCount = mediumCount; }
        public int getLowCount() { return lowCount; }
        public void setLowCount(int lowCount) { this.lowCount = lowCount; }
        public int getTotalCount() { return totalCount; }
        public void setTotalCount(int totalCount) { this.totalCount = totalCount; }
    }
}